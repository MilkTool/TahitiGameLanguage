The aim is to create a language which merges the good points of C, C++, Java, and possibly UnrealScript, adding new features along the way if needed. The main design will be based heavily around that of C++. The following additions have already been determined...

Post-assignment Operator
------------------------

If you have a function which sets the value of a variable and returns the old value then it could look like this...

	int SetValue(int new_value)
	{
		int old_value;

		// Backup current value for returning
		old_value = value;

		// Set the value
		value = new_value;

		// Return the old value to the user
		return (old_value);
	}

The post-assignment operator will, instead of assigning a value to a variable immediately, use the current value the variable yields in the calculations and then when calculation is finished, assign the value. This function could then be simplified to this...

	int SetValue(int new_value)
	{
		// value is used before it is assigned a new
		// value, therefore returning the old value
		return (value := new_value);
	}

Roughly Equal To Operator
-------------------------

This sequence of code...

	if (x > 0.5 - tolerance && x < 0.5 + tolerance)
		do_stuff;

...will test to see if x is within a certain range of 0.5, i.e. if it is roughly equal to 0.5. This could be replaced with a roughly equal to operator, like so...

	if (x ~= 0.5)
		do_stuff;

The problem occurs now of what to do with the tolerance value since obviously the programmer will want to redefine it. No clean way has been thought of to do this so perhaps this operator may be left out.

Assembler Syntax
----------------

	call			Call a script function
	calli			Call an imported function
	callim			Call an imported method


Sharing Classes, Methods, Variables and Functions
-------------------------------------------------

A way for sharing classes between the virtual machine and the executable code needs to be thought of. Sharing functions is pretty straight forward. Once a function is defined within the C/C++ code, it can be registered for use with the VM like so...

	RegisterFunction(Function, export_number);

The function has an address where it is located so this address is placed in a table at the position denoted by export_number. The code run by the VM does not know of this function until it is imported, something like this...

	import ret_type Function(parameters) : import_number;

It is the import_number which tells the VM which function to call. The function name simply associates the call in the VM code with its import number. When a function is called within the code like this...

	Function(parameters);

At compile time this function call is found and the compiler looks up the import number of the function and produces the following code...

	push		all_parameters
	calli		import_number

The VM in turn will execute this code and look up the address of the function to call in its internal list (as built by ‘RegisterFunction’). Before calling it the appropriate parameters will be taken from the VM stack and placed on the application stack.
This is relatively simplistic but can be made much easier to use by eliminating the use of the import/export number with a little extra effort. Instead of passing the export_number to ‘RegisterFunction’, the function as a string could be passed instead like...

	RegisterFunction(Function, "Function");

An array could be built up which holds the function number (generated by ‘RegisterFunction’ and most likely the array index also), the function address and the function string name. When importing the function from the VM the code would be...

	import ret_type Function(parameters);

At compile time, when this declaration is encountered a unique number is generated for it. This number is used as a parameter to ‘calli’. The binary file that the VM will run will contain a list of imported function names and the number that they were assigned. When the VM loads this binary file it will go through the list of imported functions and find their name in the function listing generated by ‘RegisterFunction’. It will the go through the binary file and replace all the import numbers specified in ‘calli’ with the correct ones.

This process becomes much nicer when the tokenising feature of C is used like so...

	#define	RegisterFunction(x)	RegFunc(x, #x)

This allows you to simply register a function like...

	RegisterFunction(Function);

The entire process becomes incredibly seamless; it just has to be double checked that the parameters to the functions are the same in both the VM and the C/C++ code.
Sharing variables becomes the same sort of affair. The following would exist on the C/C++ side...

	#define	RegisterVariable(x)	RegVar(x, #x)

	RegisterVariable(Variable);

This function will, like the new ‘RegFunc’, add Variable’s address, name and index to a simple array. In the VM, the import code would be...

	import type Variable;

When using the variable in operations like this...

	x = y + Variable;

The generated code should be...

	; Encountered y
	push		[y]
	; Encountered Variable
	pushi		import_number
	; Do the rest
	add
	pop		[x]

The same type of operation would also be available with ‘popi’. The VM binary loader would replace import_number with the correct index as generated by ‘RegVar’.

Sharing classes and their methods is a little more drawn out. In the C++ code, any methods that want to be shared with the script code have to be declared as static. This is so the address of the function can be obtained. However, static functions cannot access any member variables since they don't belong to any instance of that class so when the method is being called, a pointer to the class it's working on needs to be passed. This can be arranged with the following definition…

	#define	DECLARE_EXPORTED_METHOD(c, m)			\
		static void m(c *class_ptr, other_parameters...)

This definition needs to be used within the class definition like...

	class TestClass
	{
	public:
		DECLARE_EXPORTED_METHOD(TestClass, Method);
	};

And of course, the definition of the method would be like...

	void TestClass::Method(TestClass *class_ptr, other_params..);

On program initialisation, the VM needs to know about this method you want to export. This could be done with the following sequence...

	#define REGISTER_METHOD(m)	RegMeth((type cast)m, #m)

	REGISTER_METHOD(TestClass::Method);

The address of this static function can now be obtained. The token itself is turned into a string and both the class and method name can be split from each other. If this is the first time that the class in use has had a method registered then the VM will make a new table entry for it and assign the class a unique ID. Following that, the method will also be allocated a new table entry within that of its class, and assigned a unique ID.

A class needs to be imported into the script if the method within that class is to be accessed. Importing them both within the script can be done like...

	import class TestClass
	{
		import function ret_type Method(parameters)
		{
			...do_stuff
		}
	}

When the declaration of 'TestClass' is encountered it is assigned a unique ID and stored in the script binary at the end along with the name. The same is also done with the methods that are imported. When calling the imported method, the generated code should look like this...

	push		parameters
	callim		class_import_number, method_import_number

The VM will read this code and replace the class and method import numbers with the correct ones that it has generated. When calling the method the VM will traverse the list and find the function pointer which it will then call.

The big problem which remains now is what provides the class pointer when calling the static function? When an object is created it has an associated holding class within the C++ code; this is the instance of the class. It is the creation of these instances that needs to be managed. Each object has its own thread of virtual machine execution, a pointer to which needs to be stored within the class itself.


Operators
---------

It would be desirable for operators to work on a wide selection of objects. Treating everything, from a number to a string, as an object would be one way to do this. Perhaps the Virtual Machine can provide a standard set of  objects which the programmer will be able to use. Take the following...

	int x = 4, y = 5, z;

	z = x + y;

	string sa = "Hello ", sb = "There", sc;

	sc = sa + sb;

z will add the value of x and y to make 9 while sc will add the sa string to sb to make “Hello There”. In a stack based VM the first set of code would generate...

	push	[x]
	push	[y]
	add
	pop		[z]

The opcode ‘add’ is effectively an explicit call to a function which is part of the VM itself. If ‘int’ became an object then it could be defined like this...

	class int
	{
		operator + function_to_call(int other);
	}

This is simply just a class declaration with a member that is defined within the application C/C++ code. If this was the case then the generated code might look as follows...

	; Finds the z, nothing to do so continues within the scope
	; Finds the = operator (just normal for now) so
	;  continues in the same scope
	; Finds the x, inside an expression so pushes it on the stack
	push	[x]
	; Finds the + operator and continues within the scope
	; Finds the y, inside an expression so pushes it on the stack
	push	[y]
	; Finds the semi-colon, end of everything so it goes back up
	;  a level within the scope.
	; Currently within an addition operation so must perform that
	callop	int_class_import_number, operator_index
	; Continues back up the levels within the same scope until
	;  it’s realised that an assignment needs to be made. If this
	;  part wasn’t normal then it too would use ‘callop’
	pop	[z]


All classes created in the VM are present throughout the game but are not active threads until an object within the game requires their use. This means a class within the VM is a definition and declaration while an object that will use this class is an instantiation of it. Threads will use the same class code but each thread will have its own unique class instruction pointer and data area.
